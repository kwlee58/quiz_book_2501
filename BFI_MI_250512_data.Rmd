---
title: "BFI MI data : 250512"
author: "coop711"
date: "`r format(Sys.time(), '%Y-%m-%d %H:%M:%S')`"
output: html_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(knitr)
library(pander)
library(magrittr)
panderOptions("table.split.table", Inf)
knitr::opts_chunk$set(echo = TRUE)
```

# Data

## 출석부

```{r, xlsx}
library(readxl)
library(dplyr)
library(googlesheets4)
options(width = 180)
class_roll <- 
  read_excel("./data/class_roll_250516.xlsx",
             range = "D1:E597",
             col_names = TRUE,
             col_types = "text")
class_roll %<>%
  data.frame
class_roll %<>%
  `names<-`(c("ID", "Name"))
class_roll$ID %<>%
  as.character
str(class_roll)
```

## BFI

```{r, message = FALSE}
BFI_url <-"https://docs.google.com/spreadsheets/d/1AzqsbP3NmtrSpPEjl7C49q7SzpQSRv96Is36fPYRmOw"
BFI <- read_sheet(BFI_url)
# BFI <- "./data/BFI250512.xlsx" %>% 
#   read_excel(range = "A1:AA729",
#              col_names = TRUE)
BFI %<>%
  data.frame
BFI %<>%
  `names<-`(c("Time", "Email", "Dept", "ID", "Name", 
              "E1", "A1", "O1", "C1", "N1", "E2", "A2", "O2", "C2", "N2", "O3", "A3",
              "E", "N", "C", "A", "O", "E_Score", "N_Score", "C_Score", "A_Score", "O_Score"))
class(BFI$ID) <- "character"
class(BFI$Dept) <- "character"
str(BFI)
#> Likert Scale 값만 추출하여 숫자로 변환
BFI[6:17] %<>%
  sapply(FUN = {. %>% strsplit(split = "[.]") %>% sapply(`[`, 1)}) %>%
  as.numeric
# sapply(BFI[5:16], function(x){sapply(strsplit(x, split = "[.]"), `[`, 1)})
#> (R) 표시된 문항의 응답값을 역순으로 다시 계산
BFI[c("A2", "C2")] %<>% 
  `-` (6, .)
BFI %>% 
  head %>%
  kable
#> 구글 설문지를 사용하면서 필요없게 된 코드이나 만약을 위하여
duplicated(BFI$ID) %>% 
  which %>%
  BFI[., c("ID", "Name")]
BFI[BFI$ID %in% c("20226424", "20246620", "20242615"), c("ID", "Name")]
# BFI <- BFI[-c(117, 598), ]
# BFI <- unique(BFI)
# str(BFI)
#> 중복 제출자
BFI %>%
  filter(duplicated(ID)) %>%
  select(Time, ID, Name) %>%
  arrange(Time)
# which(duplicated(BFI$ID)) %>%
#   BFI[., c("ID", "Name")]
BFI %>%
  filter(ID %in% c("20226424", "20246620", "20242615"))
BFI <- BFI %>% 
  arrange(ID, desc(Time)) %>%
  distinct(ID, .keep_all = TRUE)
#> 중복 입력 삭제 확인
duplicated(BFI$ID) %>% 
  which %>%
  BFI[., c("ID", "Name")]

#> 학번 잘못 써서 고생시키는 녀석들 찾아내는 코드
#> 
# 1. 잘못된 id 가진 행 찾기
BFI_wrong_ids <- BFI %>%
  anti_join(class_roll, by = c("ID", "Name")) 
# 2. 잘못된 id를 따로 저장하고 수정하기
wrong_keys <- BFI_wrong_ids %>% 
  select(ID, Name)

BFI_wrong_ids <- BFI_wrong_ids %>%
  mutate(
    ID = case_when(
      ID == "2022712" ~ "20227120",
      ID == "24" & Name == "최성준" ~ "20242137",
      ID == "영어영문학과" & Name == "권유진" ~ "20221204",
      ID == "AI로봇융합" & Name == "양조은" ~ "20246745",
    TRUE ~ ID
    ),
    Name = case_when(
      Name == "최유" ~ "최유환",
      TRUE ~ Name
      )
    )

# 3. BFI 에서 id 틀린 행을 제거하고 옳은 id 갖춘 행으로 교체하기
BFI <- BFI %>%
  anti_join(wrong_keys %>% select(ID, Name), by = c("ID", "Name")) %>%
  bind_rows(BFI_wrong_ids)

#> ID 잘못 적은 친구 수정사항 확인
BFI[BFI$ID %in% setdiff(BFI$ID, class_roll$ID), c("ID", "Name")]

str(BFI)
```

```{r, eval = TRUE}
#> "중간이다"를 도배한 친구 기록 삭제
# 동일한 값으로 일관된 응답을 입력한 사용자를 적발하는 함수
identify_uniform_responses <- function(data, uniform_value = "중간이다") {
  # 각 행이 특정 값으로만 일관되는지 확인
  uniform_rows <- apply(data, 1, function(row) all(row == uniform_value))
  
  # 일관된 응답을 입력한 행 번호 또는 ID 출력
  offenders <- which(uniform_rows) # 행 번호 
}

# 예시 데이터에 적용 (ID 열이 있다고 가정)
result <- identify_uniform_responses(BFI[, 6:17], "3")

# 결과 확인
print(result)   # 일관된 응답을 입력한 행 번호
print(BFI[result, c("ID", "Name")])    # 일관된 응답을 입력한 데이터
BFI <- BFI[-result, ]
str(BFI)
```

```{r}
#> 마감일로부터 제출시점의 기간
BFI$Time <- format(BFI$Time, format = "%Y-%m-%d %H:%M:%S")
## 자정 전에 들어 온 사람은 몇 명이나?
as.Date(BFI$Time) %>%
  table
#> 날수, 시간수
BFI_days <- as.numeric(difftime("2025-05-26 00:00:00", BFI$Time, 
                                tz = "Asia/Seoul",  units = 'days'))
BFI_hours <- as.numeric(difftime("2025-05-26 00:00:00", BFI$Time, 
                                 tz = "Asia/Seoul", units = 'hours'))
```

## MI

```{r, message = FALSE}
MI_url <-"https://docs.google.com/spreadsheets/d/1wqDrGdGyqA9jqAMwLXQnNTnIdDGF0cWc6CEJmJQNJQk"
MI <- read_sheet(MI_url)
# MI <- "./data/MI250512.xlsx" %>% 
#   read_excel(range = "A1:BQ721",
#              col_names = TRUE)
MI %<>%
  data.frame
MI <- MI[, -2]
MI %<>%
  `names<-`(c("Time","Dept", "ID", "Name", 
              paste0(LETTERS[1:8], 1:56), 
              paste(LETTERS[1:8], "Score", sep = "_")))
# MI %<>%
#   `names<-`(c("Time", "Dept", "ID", "Name", 
#               paste0("Q", 1:56), 
#               paste(LETTERS[1:8], "Score", sep = "_")))
MI$ID %<>% 
  as.character

#> 중복 제출자
MI %>%
  filter(duplicated(ID)) %>%
  select(Time, ID, Name) %>%
  arrange(Time)
# which(duplicated(MI$ID)) %>%
#   MI[., c("ID", "Name")]
MI %>%
  filter(ID %in% c("20242615")) %>%
  select(Time, ID, Name)
MI <- MI %>% 
  arrange(ID, desc(Time)) %>%
  distinct(ID, .keep_all = TRUE)
#> 중복 입력 삭제 확인
duplicated(MI$ID) %>% 
  which %>%
  MI[., c("ID", "Name")]
# MI <- unique(MI)
# str(MI)
MI[5:60] %<>%
  sapply(FUN = {. %>% strsplit(split = "[.]") %>% sapply(`[`, 1)}) %>%
  as.numeric
str(MI)
```

```{r, eval = TRUE}
# 동일한 값으로 일관된 응답을 입력한 사용자를 적발하는 함수
identify_uniform_responses <- function(data, uniform_value = "중간이다") {
  # 각 행이 특정 값으로만 일관되는지 확인
  uniform_rows <- apply(data, 1, function(row) all(row == uniform_value))
  
  # 일관된 응답을 입력한 행 번호 또는 ID 출력
  offenders <- which(uniform_rows) # 행 번호 
}
# 예시 데이터에 적용 (ID 열이 있다고 가정)
result_M <- identify_uniform_responses(MI[, 5:60], "3")

# 결과 확인
print(result_M)   # 일관된 응답을 입력한 행 번호
print(MI[result_M, c("ID", "Name")])    # 일관된 응답을 입력한 데이터
# str(MI)
# 부적절한 응답 삭제
MI <- MI[-result_M, ]
str(MI)
```

```{r, eval = FALSE}
str(MI)
kable(head(MI[c(3, 5:18)]))
kable(head(MI[c(3, 19:32)]))
kable(head(MI[c(3, 33:46)]))
kable(head(MI[c(3, 47:60)]))
```

## 학번오류, 불참자

```{r}
# 1. 잘못된 id 가진 행 찾기
MI_wrong_ids <- MI %>%
  anti_join(class_roll, by = c("ID", "Name")) 
# 2. 잘못된 id를 따로 저장하고 수정하기
wrong_keys <- MI_wrong_ids %>% 
  select(ID, Name)

MI_wrong_ids <- MI_wrong_ids %>%
  mutate(
    ID = case_when(
      ID == "20227070" ~ "20227080",
      ID == "24" & Name == "최성준" ~ "20242137",
      ID == "202041726" ~ "20241726",
      ID == "2024383" ~ "20243831",
      ID == "20242556" ~ "20242553",
      ID == "영어영문학과" & Name == "원예진" ~ "20241217",
      ID == "서예림" & Name == "20243817" ~ "20243817",
      ID == "20242675" ~ "20246275",
    TRUE ~ ID
    ),
    Name = case_when(
      Name == "최유" ~ "최유환",
      TRUE ~ Name
      )
    )

# 3. MI 에서 id 틀린 행을 제거하고 옳은 id 갖춘 행으로 교체하기
MI <- MI %>%
  anti_join(wrong_keys %>% select(ID, Name), by = c("ID", "Name")) %>%
  bind_rows(MI_wrong_ids)

#> ID 잘못 적은 친구 수정사항 확인
MI[MI$ID %in% setdiff(MI$ID, class_roll$ID), c("ID", "Name")]
MI %>%
  anti_join(class_roll, by = "ID") 
#> 각 조사 불참자 
#> BFI 불참자
# setdiff(class_roll$ID, BFI$ID)
class_roll %>%
  anti_join(BFI, by = "ID")
#> MI 불참자
# setdiff(class_roll$ID, MI$ID)
class_roll %>%
  anti_join(MI, by = "ID")
#> BFI 는 참여, MI 는 불참
setdiff(BFI$ID, MI$ID) %>%
  `%in%`(BFI$ID, .) %>%
  `[`(BFI, ., c("ID", "Name")) %>%
  .[order(.$ID),]
#> MI 는 참여, BFI 는 불참
setdiff(MI$ID, BFI$ID) %>%
  sort %>%
  `%in%`(MI$ID, .) %>%
  `[`(MI, ., c("ID", "Name")) %>%
  .[order(.$ID),]
# MI$Name
# class_roll$Name
# str(MI)

#> 마감일로부터 제출시점의 기간
MI$Time <- format(MI$Time, format = "%Y-%m-%d %H:%M:%S")
## 자정 전에 들어 온 사람은 몇 명이나?
as.Date(MI$Time) %>%
  table
MI_days <- 
  as.numeric(difftime("2025-05-26 00:00:00", MI$Time, 
                      tz = "Asia/Seoul", units = 'days'))
MI_hours <- 
  as.numeric(difftime("2025-05-26 00:00:00", MI$Time, 
                      tz = "Asia/Seoul", units = 'hours'))
str(MI)
```

## Time

### BFI

```{r, echo = TRUE, eval = TRUE}
par(family = "KoPubWorldDotum Medium")
BFI_days %>%
  cut(breaks = c(0:14), include.lowest = TRUE) %>%
  table %>%
#  cbind("계" = rowSums(.)) %>%
#  rbind("계" = colSums(.)) %>%
  pander(caption = "일 단위")
BFI_days %>%
  cut(breaks = c(0:14), include.lowest = TRUE) %>%
  table %>%
  chisq.test %>%
  pander
BFI_days %>%
  cut(breaks = c(0:14), include.lowest = TRUE) %>%
  table %>%
  rev %>%
  barplot(space = 0, 
          names.arg = rep(c("월", "화", "수", "목", "금", "토", "일"), 2), 
          col = c(rep("white", 13), "pink"))
title(main = "일 단위 BFI 제출 횟수")
```

### MI

```{r, echo = TRUE, eval = TRUE}
par(family = "KoPubWorldDotum Medium")
MI_days %>%
  cut(breaks = c(0:14), include.lowest = TRUE) %>%
  table %>%
#  cbind("계" = rowSums(.)) %>%
#  rbind("계" = colSums(.)) %>%
  pander(caption = "일 단위")
MI_days %>%
  cut(breaks = c(0:14), include.lowest = TRUE) %>%
  table %>%
  chisq.test %>%
  pander
MI_days %>%
  cut(breaks = c(0:14), include.lowest = TRUE) %>%
  table %>%
  rev %>%
  barplot(space = 0, 
          names.arg = rep(c("월", "화", "수", "목", "금", "토", "일"), 2), 
          col = c(rep("white", 13), "pink"))
title(main = "일 단위 MI 제출 횟수")
```

## Working Data

```{r, echo = TRUE}
BFI <- BFI[, -c(3, 5)]
MI <- MI[, -c(2, 4)]
## piping을 이용한 다음 대안들을 개선해 보세요.
# lapply(list(1:15, c(1, 16:29), c(1, 30:43), c(1, 44:57)), 
#        function(x) MI %>% `[`(x) %>% head %>% kable)
# list(1:15, c(1, 16:29), c(1, 30:43), c(1, 44:57)) %>%
#   lapply(function(x) MI %>% `[`(x) %>% head %>% kable)
# list(1:15, c(1, 16:29), c(1, 30:43), c(1, 44:57)) %>%
#   lapply(. %>% {kable(head(MI[.]))})

```

### Save Data

```{r, save.image}
saveRDS(BFI, file = "./BFI250512.RDS")
saveRDS(MI, file = "./MI250512.RDS")
save.image("./BFI_MI_250512.RData")
```

